## 06-01

오늘 다른 분들의 github을 보게 되었는데 생각보다 열심히 공부하시는 분들이 많아서 자극을 많이 받았다.

오늘은 CSS 관련 문제를 해결하게 되었다.

### 문제

특정 class(css)가 적용되는 경우 디자인이 깨지는 오류가 있었다.

### 원인

before  
특정 클래스가 적용되기 전 css 적용은 다음과 같다.  
parent의 position이 relative고 child의 position이 absoulte이기 때문에 컨테이닝 블록은 바로 상위의 parent가 된다.  
이런 경우 문제 없이 디자인이 나온다.

```html
<div id="parent" style="position: relative;">
  <div id="child" style="position: absoulte;"></div>
</div>
```

after  
하지만, 특정 클래스가 적용되면 parent의 position이 static으로 바뀌면서
child의 컨테이닝 블록은 상위의 parent가 되지 않고 더욱 상위의 block을 가리키게 된다.
결국, 동적으로 class를 넣어 줄 때 css selector 규칙과 겹쳐서 position: static이 적용되고 있었다.

```html
<div id="parent" style="position: static;">
  <div id="child" style="position: absoulte;"></div>
</div>
```

### 해결

방법은 여러가지가 있다.

- !important keyword를 추가한다.
- inline Style을 적용한다.

하지만, 해당 문제는 class 이름이 중복되어 기존 CSS가 적용되고 있었다.
따라서 class 이름을 변경해주었다.

### ref

- https://developer.mozilla.org/ko/docs/Web/CSS/Containing_block

오늘 공부한 것

- 자바스크립트 프론트엔드 프로젝트 가이드 1p ~ 87p 학습 - TDD 적용
- 코어소리영어 신왕국의 '타임투게더' 24강 학습

## 06-02

Chrome Dev Tools Performance Panel을 통해 성능을 측정해봤다.  
reflow를 테스트하기 위해 fragment를 적용한 케이스와 그렇지 않은 케이스를 비교한 결과 렌더링 비용이 똑같았다.  
얼핏 브라우저에서 reflow 최적화를 해준다고 본것 같지만 확실하지는 않아 확인이 필요하다.  
그리고 오늘 innerText가 강제로 reflow를 발생시킨다는 사실을 처음 알았다.  
innerText 대신 textContent를 쓰면 reflow를 방지할 수 있다.

ref: https://developer.mozilla.org/ko/docs/Web/API/Node/textContent

- 점심 등 운동
- innerText는 reflow를 발생시킨다.
- MagicMirror Weather Module 연동

## 06-03

최근 하나의 기능을 가지고 리팩토링을 진행하고 있다.  
테스트 코드가 없고 테스트 코드 작성에 투자할 일정도 없지만
해당 기능에 대한 이해도가 높아지고 겉보기 동작을 알고 있어서 진행하고 있다.  
사실 테스트 코드가 없어서 겉보기 동작을 깨트리지 않고 리팩터링 하는게 시간도 오래 걸리고 부담으로 다가온다.

리팩토링을 진행하면서 다양한 악취와 마주했다.(긴 함수, 중복 코드, 기이한 이름 등)

그런데 문득 이런 생각이 들었다.  
과연 수 많은 개발자들이 이런 악취를 알아차리지 못했을까?
당연히 아닐 것이다.  
알고 있지만 고치지 못했을 거다.  
현재 배포 프로세스는 코드를 수정하면 테스트를 맡기고 메인 서버에 배포한다. 혹시나 오류가 생기면 다시 수정해서 테스트를 맡긴다.  
오류에 대한 즉각적인 피드백도 어렵고, 프로세스가 오래 걸리다 보니 코드를 고치는 일이 부담이 될 것이다.  
내가 수정한 코드에 대해 테스트 범위를 잡는 것도 일이다.

하지만, 테스트 코드가 있다면 상황은 많이 괜찮아 졌을 거라고 기대한다.  
예전에는 테스트 코드 번거롭고 왜 하는지 이해가 되지 않았지만 이러한 경험을 통해 테스트 코드의 필요성을 느낄 수 있어서 다행이라고 생각한다.

- MagicMirror A2D Telegram Bot 연동
- 코어소리영어 신왕국의 '타임투게더' 25강 학습

## 06-04

나는 정보보안을 공부하면서 항상 전체적인 흐름, 원리, 내부 구조를 몹시 궁금해 했다.  
웹 해킹에서 SQL Injection, XSS 공격 기법들이 발생한 원리, 공격 포인트, 방어할 수 있는 방법들을 공부하면서 자연스럽게 얻게 된 습관인 것 같다.  
지금은 개발을 하고 있지만 깊게 알려고 하는 습관은 여전하다.  
최근에는 React Framework의 내부 구조에 흥미가 생겨서 Event System, bubbling 되지 않는 event는 어떻게 Event System을 사용하게 하는지 등을 알아본 적이 있다.  
그러다 최근 좋은 글을 발견 했는데 한동안은 해당 글을 통해 React 내부 구조를 공부할 것 같다.  
ref: https://goidle.github.io/

- Refactoring-Book Repository 코드에서나는 악취 정리
- React 내부 구조 공부

## 06-05

이빨 관리를 열심히 했지만 충치가 생겨서 오늘 치료를 받고 피부과에도 다녀왔다.

- MagicMirror 관련 모듈 조사
- 코어소리영어 신왕국의 '타임투게더' 26강 학습

## 06-06

- 코어소리영어 신왕국의 '타임투게더' 27강 학습
- 자바스크립트 프론트엔드 프로젝트 가이드 Chapter 4, 5 가위바위보 - TDD 적용

## 06-07

리액트 Hook에 관한 글을 살펴봤다.

- 리액트 Hook 구조에 관한 글 - https://goidle.github.io/react/in-depth-react-hooks_1/

## 06-08

리팩토링을 진행하고 있는데 점점 오버엔지니어링을 하고 있다는 느낌이 든다.  
분명 더 읽기 쉽고 유지보수 쉽게 만들 수 있을것 같다는 생각에 현재 멀쩡한 코드도 뜯어 고치려고 하는 경향이 있다.  
아무래도 리팩토링할 기회가 많이 없어서 할 때 전부 뜯어고치자는 생각이 드는 것 같다.

- 자바스크립트 프론트엔드 프로젝트 가이드 Chapter 6 로또 번호 생성기 144p ~ 170p 학습 - TDD 진행중
- 코어소리영어 신왕국의 '타임투게더' 28강 학습
- 리액트 Hook 구조에 관한 글 2 - https://goidle.github.io/react/in-depth-react-hooks_2/

## 06-09

현재 읽고 있는 책 자바스크립트 프론트엔드 프로젝트 가이드는 초보자를 위한 책이다.  
해당 프로젝트를 사용하기 위해 JS 언어의 기초 DOM 조작 방법 등을 상세하게 알려준다.  
하지만, 기초 관련 책들은 이미 접했기 때문에 프로젝트에 대한 아이디어만 가지고 와서 TDD를 적용하고 있다.  
아무래도 처음 TDD를 적용하고 있어서 여러 문제에 마주하고 있다.

- 테스트 커버리지는 어느정도 가져갈 것인가
- 랜덤 값을 반환하는 함수는 어떻게 테스트 할 것인가

JS 관련 Test Code 작성에 관한 좋은 책을 찾지 못해서 아마 부족한 부분은 웹 자료나 온라인 강의를 통해 채우게 될 것 같다.

오늘 배운 것

- 자바스크립트 프론트엔드 프로젝트 가이드 Chapter 6 로또 번호 생성기 - TDD 완료
- 코어소리영어 신왕국의 '타임투게더' 29강 학습
- 리액트 Scheduler에 관한 글 - https://goidle.github.io/react/in-depth-react-scheduler_1/

## 06-10

리팩토링 책에서 파생 변수를 질의함수로 바꾸기라는 리팩토링 기법이 있다.  
예를 들어, 다음 예제와 같이 처리하면 totalValue의 계산 과정이 다른 곳에 퍼져있어 관리 포인트가 늘어나며 의미 전달력도 높지 않다.  
(보통 성능 때문에 다음과 같이 처리를 하지만 무의미한 성능 개선일 수 있다.)

따라서, totalValue를 구하는 시점에 this.\_products.reduce((total, product) => total + product.value, 0); 과 같이 처리하는게 좋다.

이 얘기를 꺼낸 이유는 최근 리팩터링을 진행하면서 다음과 같은 상황에 마주했기 때문이다.

호출 시점에 간단히 구할 수 있지만 값을 업데이트 하기 위해 init, render, event 발생 시 마다 업데이트 로직을 넣어주고 있었다.  
이로 인해, 에러 발생 시 확인해야 할 시점 및 모듈이 많아서 대응에도 지장이 있고 새로운 기능 추가에도 어려움이 있었다.

앞으로는 성능에 큰 문제가 없다면 개발할 때 파생 변수를 만들지 말고 질의함수를 사용하도록 해야 겠다.

```javascript
class Test {
  // ... 중략
  get totalValue() {
    this._totalValue;
  }

  addProduct(product) {
    this._products.push(product);

    // 관련 없는 함수에서 totalValue의 값 업데이트
    this._totalValue += product.value;
  }
}
```

- FastCampus TDD - 테스트 대역 강의 학습
- 리액트 코어 관련 글 - https://github.com/Bogdan-Lyashenko/Under-the-hood-ReactJS/blob/master/stack/languages/korean/book/Part-0.md

## 06-11

오늘은 리액트 코어 컨셉에 관한 글을 읽게 되었다.  
아무래도 한번에 이해하기에는 무리가 있는 것 같다.  
전체적인 그림을 그릴 수 있을 때 까지 노력해야겠다.

- 리액트 React Element, React Component에 관한 글 - https://medium.com/@dan_abramov/react-components-elements-and-instances-90800811f8ca

## 06-12

- 리액트 공식 문서 - 주요 개념 JSX 소개, 엘리먼트 렌더링, Component와 Props 학습

## 06-13

최근 리액트 코어에 관해 관심있게 보고 있는데 우선 공식 문서에서 내가 참고할 부분이 있는지 확인할겸 전체 내용을 흝어보고 있다.  
이미 알고있던 내용이지만 새롭게 얻는 지식도 있어서 흥미로웠다.  
폼 같은 경우 JSX와 HTML Element의 사용방법이 달랐다.

- 리액트 공식 문서 - State와 생명주기, 이벤트 처리하기, 조건부 렌더링, 리스트와 Key, 폼, State 끌어올리기

## 06-14

오늘은 생각보다 많은 양을 학습 한 것 같다.  
모든 것들을 정리하고 기억하지는 못하지만 한 번이라도 읽어본 것에 의의를 두고자 한다.  
이번에 처음으로 출퇴근 시간에 블로그 글을 읽어 봤는데 시간을 활용하기에 좋은 것 같다.

리액트는 어느 정도 다룰줄 알기에 공식 문서를 통해서는 이미 알고 있는 정보를 다시 정리하는데 좋았다.

**자동 배칭이나 Fiber** 같은 경우에는 굉장히 흥미로웠다.  
일반적으로 state가 업데이트되면 리렌더링이 된다.
그렇다면, 만약 click 이벤트 안에서 다음 처럼 state가 두 번 바뀌면 어떻게 될까
React가 이 state 업데이트를 하나의 re-render로 묶어서 수행한다.(batching)  
하지만, 지금은 브라우저 이벤트에서만 batching 되고 있다. (아마 root element에 event delegation으로 처리하는 로직 중에 있을 것 같다.)  
비동기, native event handler(addEventListener로 등록하는 등)는 batching 되지 않는다.

하지만 React 18에서는 상관없이 자동 배칭된다.

```javascript
const handleClick = e => {
  setCount(c => c + 1);
  setToggle(f => !f);
};
```

**테스트 관련 내용도 흥미로웠다.**
mock의 위험성은 다음과 같다.  
상태 검증이 아닌 행위 검증이기 때문에 구현 코드의 지식이 테스트 코드에 존재하게 된다.  
인풋에 대한 아웃풋을 검증하는 상태 검증과는 다르게 행위 검증은 함수 A가 구현 하는 코드에서 함수 B를 호출하는지 어떤 매개변수를 전달하는지 등을 검증한다. 즉 구현에 대해 신경을 써야 한다.

- 캡슐화된 정보가 테스트 코드에 존재하게 된다.
- 테스트 코드가 구현 코드에 의존하게 된다.
- 리팩토링은 내부 구조를 개선하는 일인데 테스트 코드가 구현 코드에 의존하기 때문에 테스트가 깨지기 쉽다.

오늘 공부한 것

- 리액트 공식 문서 - 합성 vs 상속, React로 생각하기 학습
- 리액트 자동 배칭, Fiber Architecture ref: https://immigration9.github.io/ 글 정독
- 패스트 캠퍼스 TDD - Mockists vs Classicists
- 코어소리영어 신왕국의 '타임투게더' 30강 학습
